\section*{序言}
如果您是并行编程的新手，那也没关系。 如果您从未听说过 SYCL 或 DPC++ 编译器，那也没关系

与 CUDA 中的编程相比，使用 SYCL 的 C++ 提供了超越 NVIDIA 的可移植性和超越 GPU 的可移植性，
并且随着现代 C++ 的发展而紧密结合以增强它。 带有 SYCL 的 C++ 在不牺牲性能的情况下提供了这些优势。

带有 SYCL 的 C++ 使我们能够利用 CPU、GPU、FPGA 和未来处理设备的组合功能来加速我们的应用程序，
而无需依赖任何一家供应商。

SYCL 是行业驱动的 Khronos Group 标准，通过 C++ 添加了对数据并行性的高级支持，以利用加速（异构）系统。 
SYCL 为 C++ 编译器提供了与 C++ 和 C++ 构建系统高度协同的机制。 
DPC++是一个基于LLVM的开源编译器项目，添加了SYCL支持。 
本书中的所有示例都应适用于任何支持 SYCL 2020 的 C++ 编译器，包括 DPC++ 编译器。

如果您是一位不太精通 C++ 的 C 程序员，那么您有一个很好的伙伴。 
本书的几位作者很高兴地分享说，他们通过阅读像本书这样使用 C++ 的书籍，学到了很多 C++ 知识。 
只要有一点耐心，想要编写现代 C++ 程序的 C 程序员也应该可以理解这本书。

\subsection*{第二版}
得益于不断增长的 SYCL 用户社区的反馈，我们能够添加内容来帮助比以往更好地学习 SYCL。

此版本使用 SYCL 2020 教授 C++。第一版早于 SYCL 2020 规范，
与第一版所教授的内容仅略有不同（此版本中 SYCL 2020 最明显的变化是头文件位置、设备选择器语法和 删除显式主机设备）。

\begin{remark}
	有关更新的 SYCL 信息（包括任何已知书籍勘误表）的重要资源，
	包括书籍 Github (https://github.com/Apress/data-parallel-CPP)、
	Khronos Group SYCL 标准网站 (www.khronos.org/sycl) ，
	以及一个重要的 SYCL 教育网站 (https://sycl.tech)。
\end{remark}

第 20 章和第 21 章是受本书第一版读者鼓励而添加的内容。

我们添加了第 20 章来讨论后端互操作性。 SYCL 2020 标准的主要目标之一是为具有多种架构的众多供应商的硬件提供广泛支持。 
这需要扩展到 SYCL 1.2.1 的仅 OpenCL 后端支持之外。 
虽然一般来说“它确实有效”，但第 20 章为那些认为在这个级别上理解和交互很有价值的人更详细地解释了这一点。

对于经验丰富的 CUDA 程序员，我们添加了第 21 章，以在方法和词汇方面将带有 SYCL 概念的 C++ 与 CUDA 概念明确连接起来。 
虽然表达异构并行性的核心问题在本质上是相似的，但带有 SYCL 的 C++ 由于其多供应商和多架构方法而提供了许多好处。 
第21章是我们唯一提到CUDA术语的地方； 本书的其余部分教授如何使用 C++ 和 SYCL 术语及其开放的多供应商、多架构方法。 
在第 21 章中，我们强烈建议查看开源工具“SYCLomatic”（github.com/oneapi-src/SYCLomatic），
它有助于自动迁移 CUDA 代码。 因为它很有帮助，所以我们建议将其作为迁移代码的首选第一步。 
使用带有 SYCL 的 C++ 的开发人员报告称，在从 CUDA 移植的代码和带有 SYCL 的原始 C++ 代码上，
在 NVIDIA、AMD 和 Intel GPU 上都取得了出色的结果。 
使用 SYCL 生成的 C++ 提供了 NVIDIA CUDA 无法实现的可移植性。

C++、SYCL 和编译器（包括 DPC++）的发展仍在继续。 
在我们一起学习如何使用 C++ 和 SYCL 为异构系统创建程序之后，尾声中讨论了对未来的展望。

我们希望本书能够支持和帮助 SYCL 社区的发展，并帮助促进使用 SYCL 进行 C++ 数据并行编程。

\subsection*{本书的结构}
本书带领我们踏上一段旅程，了解如何使用 C++ 和 SYCL 成为一名高效的加速/异构系统程序员。

\subsubsection*{第 1-4 章：奠定基础}
当第一次使用 SYCL 接触 C++ 时，按顺序阅读第 1-4 章非常重要。

第一章通过涵盖新的或值得我们刷新的核心概念奠定了第一个基础。

第 2-4 章为理解使用 SYCL 进行 C++ 数据并行编程奠定了基础。 
当我们读完第 1-4 章时，我们将为 C++ 数据并行编程打下坚实的基础。 第 1 章至第 4 章相互关联，最好按顺序阅读。

\subsubsection*{第 5-12 章：构建基础}

随着基础的建立，第 5 章至第 12 章通过在一定程度上相互借鉴来填补重要的细节，同时可以根据需要轻松地在之间跳转。 
所有这些章节对于所有使用 SYCL 的 C++ 用户都应该有价值。

\subsubsection*{第 13-21 章：SYCL 实践提示/建议}

最后几章提供了针对特定需求的建议和详细信息。 我们鼓励至少浏览所有内容以找到对您的需求重要的内容。

\subsubsection*{结语：对未来的推测}

本书最后的尾声讨论了使用 SYCL 的 C++ 以及 SYCL 的数据并行 C++ 编译器可能和潜在的未来方向。

我们祝您在学习通过 SYCL 使用 C++ 时一切顺利。

\newpage
\section*{前言}
SYCL 2020 是并行计算领域的一个里程碑。我们第一次拥有了一个现代、稳定、功能完整且可移植的开放标准，
可以针对所有类型的硬件，您手中的书是学习 SYCL 2020 的首要资源。

计算机硬件开发是由我们解决更大、更复杂问题的需求驱动的，但这些硬件进步在很大程度上是无用的，
除非像你我这样的程序员拥有允许我们实现我们的想法并以合理的努力利用可用能力的语言。
有许多令人惊叹的硬件示例，使用它们的第一个解决方案通常是专有的，
因为它可以节省时间，而不必为委员会就标准达成一致而烦恼。
然而，在计算史上，它们最终总是以供应商锁定告终——无法与允许开发人员针对任何硬件和共享代码的开放标准竞争
——因为最终全球社区和生态系统的资源远远大于任何单个供应商，更不用说开放软件标准如何推动硬件竞争了。

在过去的几年里，我的团队非常荣幸地通过开发 GROMACS（世界上使用最广泛的科学 HPC 代码之一）为塑造新兴的 SYCL 生态系统做出了贡献。 
我们需要我们的代码在世界上每台超级计算机以及我们的笔记本电脑上运行。 
虽然我们不能承受性能损失，但我们也依赖于成为更大社区的一部分，其他团队在我们依赖的库上投入精力，
那里有可用的开放编译器，以及我们可以招募人才的地方。 
自本书第一版以来，SYCL 已发展成为这样一个社区； 除了几个供应商提供的编译器之外，
我们现在还有一个针对所有硬件的主要社区驱动的实现
\footnote{Community-driven implementation from Heidelberg University: tinyurl.com/ HeidelbergSYCL}
，并且全球有数千名开发人员分享经验、为培训活动做出贡献并参与论坛。 
开源的杰出力量——无论是应用程序、编译器还是开放标准——是我们可以深入了解、学习、借用和扩展。 
正如我们反复从 Intel 主导的 LLVM 实现中的代码 \footnote{DPC++ compiler project: github.com/intel/llvm} 、海德堡大学社区驱动的实现以及其他几个代码中学习一样，
您可以使用我们的公共存储库 \footnote{GROMACS: gitlab.com/gromacs/gromacs/} 来比较大型生产代码库中的 CUDA 和 SYCL 实现，
或者 借用满足您需求的解决方案 - 因为当您这样做时，您正在帮助进一步扩展我们的社区。

也许令人惊讶的是，数据并行编程作为一种范式可以说比消息传递通信或显式多线程等经典解决方案要容易得多，
但它对我们这些在专注于硬件和显式数据放置的旧范式中度过了几十年的人来说带来了特殊的挑战。
在小规模上，明确决定如何在少数几个进程之间移动数据对我们来说是微不足道的，
但随着问题扩展到数千个单元，在不引入错误或让硬件闲置等待数据的情况下管理复杂性成为一场噩梦。
使用 SYCL 进行数据并行编程解决了这个问题，它主要要求我们显式表达算法的固有并行性，但一旦我们这样做了，
编译器和驱动程序将主要处理数以万计的功能单元的数据局部性和调度。
为了在数据并行编程中取得成功，重要的是不要将计算机视为执行一个程序的单个单元，而是将其视为独立工作的单元的集合

SYCL 的主要优势之一是与现代 C++ 的紧密结合。 乍一看，这似乎令人望而生畏。 
C++ 不是一门容易完全掌握的语言（我当然还没有），但是 Reinders 和合著者牵着我们的手，带领我们走上了一条道路，
我们只需要学习一些 C++ 概念就可以开始并在实际数据中发挥生产力 - 并行编程。 
然而，随着我们经验的积累，SYCL 2020 允许我们将其与 C++17 的极端通用性结合起来，编写可以动态针对不同设备的代码，
或者依赖使用 CPU、GPU 和网络单元的异构并行性 并行执行不同的任务。 
SYCL 并不是一个用于启用加速器的单独的固定解决方案，而是有望成为我们在 C++ 中表达数据并行性的通用方式。 
SYCL 2020 标准现在包含一些以前仅作为供应商扩展提供的功能，
例如统一共享内存、子组、原子操作、归约、更简单的访问器以及许多其他概念，这些概念使代码更清晰，
并促进开发和开发 从标准 C++17 或 CUDA 移植，让您的代码面向更多样化的硬件。 
本书对所有这些内容进行了精彩且易于理解的介绍，您还将了解到 SYCL 将如何随着 C++ 的快速发展而发展。

这在理论上听起来不错，但 SYCL 在实践中的可移植性如何？ 我们的应用程序是一个代码库的示例，它的优化非常具有挑战性，
因为数据访问模式是随机的，每个步骤中要处理的数据量是有限的，我们需要实现每秒数千次迭代，
并且我们都受到内存的限制 带宽、浮点和整数运算——它与简单的数据并行问题截然相反。 
我们花了二十多年的时间为多种 GPU 架构编写汇编 SIMD 指令和本机实现，
我们第一次接触 SYCL 时遇到了适应差异和向驱动程序和编译器开发人员报告性能回归的痛苦。 
然而，截至 2023 年春季，我们的 SYCL Kernel不仅可以通过单个代码库，
甚至可以通过单个预编译的二进制文件在所有 GPU 架构上实现 80-100\% 的本机性能。

SYCL 还很年轻，并且拥有快速发展的生态系统。 虽然还有一些东西尚未成为该语言的一部分，但 SYCL 是独一无二的，
它是唯一可成功针对所有现代硬件的性能可移植标准。 
无论您是想要学习并行编程的初学者、对数据并行编程感兴趣的经验丰富的开发人员，
还是需要将 100,000 行专有 API 代码移植到开放标准的维护者，这第二版都是您需要成为的唯一一本书 这个社区的一部分。
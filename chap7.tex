\section{Buffers}
在本章中，我们将学习缓冲区抽象。 我们在上一章中了解了统一共享内存（USM），这是一种基于指针的数据管理策略。 USM 迫使我们思考内存存放在哪里以及什么应该在哪里访问。 缓冲区抽象是一个更高级别的模型，它向程序员隐藏了这一点。 缓冲区只是代表数据，运行时的工作就是管理数据在内存中的存储和移动方式。

本章介绍了管理数据的另一种方法。 缓冲区和 USM 之间的选择通常取决于个人喜好和现有代码的风格，并且应用程序可以自由地混合和匹配这两种风格以表示应用程序中的不同数据。

USM 只是公开不同的内存抽象。 USM 有指针，缓冲区是更高级别的抽象。 缓冲区的抽象级别允许在应用程序内的任何设备上使用其中包含的数据，其中运行时管理使该数据可用所需的任何内容。 USM 基于指针的模型可能更适合使用基于指针的数据结构（例如链表、树或其他结构）的应用程序。 将缓冲区改造为已经使用指针的现有代码也可能更加棘手。 但是，缓冲区保证可以在系统中的每个设备上工作，而某些设备可能不支持特定（或任何）USM 模式。 选择很好，所以让我们深入研究缓冲区。

我们将更仔细地了解缓冲区是如何创建和使用的。 如果不讨论访问器，对缓冲区的讨论就不完整。 虽然缓冲区抽象了我们在程序中表示和存储数据的方式，但我们并不直接使用缓冲区访问数据。 相反，我们使用访问器对象来通知运行时我们打算如何使用正在访问的数据，并且访问器与任务图中强大的数据依赖机制紧密耦合。 在我们介绍了可以使用缓冲区执行的所有操作之后，我们还将探索如何在程序中创建和使用访问器。


\subsection{缓冲器}
缓冲区是数据的高级抽象。 缓冲区不一定绑定到单个位置或虚拟内存地址。 事实上，运行时可以自由地使用内存中的许多不同位置（甚至跨不同的设备）来表示缓冲区，但运行时必须确保始终为我们提供一致的数据视图。 缓冲区可以在主机和任何设备上访问。

缓冲区类是一个具有三个模板参数的模板类，如图 7-1 所示。 第一个模板参数是缓冲区将包含的对象的类型。 此类型必须是设备可复制的，这扩展了 C++ 定义的普通可复制的概念。 可简单复制的类型可以安全地逐字节复制，而无需使用任何特殊的复制或移动构造函数。 设备可复制类型将此概念递归地扩展到某些 C++ 类型，例如 std::pair 或 std::tuple。 下一个模板参数是描述缓冲区维数的整数。 最后的模板参数是可选的，默认值通常是使用的值。 此参数指定一个 C++ 样式的分配器类，用于在主机上执行缓冲区所需的任何内存分配。 首先，我们将研究创建缓冲区对象的多种方法。

\subsubsection{缓冲区创建}

\subsubsection{我们可以用缓冲区做什么？}

\subsection{访问器}

\subsubsection{访问器创建}

\subsubsection{我们可以用访问器做什么？}

\subsection{概括}
\section{CPU 编程}
内核编程最初作为一种 GPU 编程方式而流行。 随着内核编程的普遍化，了解内核编程风格如何影响代码到 CPU 的映射非常重要。

CPU 已经发展了很多年。 2005 年左右发生了重大转变，当时时钟速度提高所带来的性能提升逐渐减弱。 并行性成为受欢迎的解决方案——CPU 生产商没有提高时钟速度，而是引入了多核芯片。 计算机在同时执行多项任务时变得更加有效！

虽然多核作为提高硬件性能的途径盛行，但要实现软件性能的提升需要付出不小的努力。 多核处理器要求开发人员提出不同的算法，这样硬件的改进才会引人注目，但这并不总是那么容易。 我们拥有的核心越多，让它们高效地忙碌就越困难。 SYCL 是应对这些挑战的编程语言之一，它具有许多有助于利用 CPU（和其他体系结构）上各种形式的并行性的结构。

本章讨论 CPU 架构的一些细节、CPU 硬件通常如何执行 SYCL 应用程序，并提供为 CPU 平台编写 SYCL 代码时的最佳实践。

\subsection{性能注意事项}
SYCL 为并行化我们的应用程序或从头开始开发并行应用程序铺平了一条可移植的路径。 应用程序在 CPU 上运行时的性能很大程度上取决于以下因素：

• 内核代码启动和执行的底层性能

• 在并行内核中运行的程序的百分比及其可扩展性

• CPU 利用率、有效的数据共享、数据局部性和负载平衡

• 工作项之间的同步和通信量

• 创建、恢复、管理、挂起、销毁和同步工作项执行的任何线程所引入的开销，该开销受串行到并行或并行到串行转换数量的影响

• 共享内存引起的内存冲突（包括错误共享内存）

• 共享资源（例如内存、写入组合缓冲区和内存带宽）的性能限制

此外，与任何处理器类型一样，CPU 可能因供应商而异，甚至因产品一代而异。 适用于一种 CPU 的最佳实践可能并非适用于其他 CPU 和配置的最佳实践。

\subsection{多核 CPU 的基础知识}

\subsection{SIMD 硬件基础知识}

\subsection{利用线程级并行性}

\subsubsection{线程亲和力洞察}

\subsubsection{注意第一次接触记忆}

\subsection{CPU 上的 SIMD 矢量化}

\subsubsection{确保SIMD执行合法性}

\subsubsection{SIMD 掩蔽和成本}

\subsubsection{避免结构数组以提高 SIMD 效率}

\subsubsection{数据类型对 SIMD 效率的影响}

\subsubsection{使用 single\_task 执行 SIMD}

\subsection{概括}